import { importedFuncs, BuiltinFuncs, createImport } from '../compiler/builtins.js';
import { TYPES } from '../compiler/types.js';
import { Valtype } from '../compiler/wasmSpec.js';
import fs from 'node:fs';
import '../compiler/prefs.js';

// Helper function to read typed arrays from WASM memory
const read = (ta, memory, ptr, length) => {
  if (ta === Uint8Array) return new Uint8Array(memory.buffer, ptr, length);
  return new ta(memory.buffer.slice(ptr, ptr + length * ta.BYTES_PER_ELEMENT), 0, length);
};

// Helper function to read byte strings from WASM memory  
const readByteStr = (memory, ptr) => {
  const length = read(Uint32Array, memory, ptr, 1)[0];
  return Array.from(read(Uint8Array, memory, ptr + 4, length)).map(x => String.fromCharCode(x)).join('');
};

// Helper function to write byte strings to WASM memory
let dv;
const writeByteStr = (memory, ptr, str) => {
  const length = str.length;

  if (dv?.memory !== memory) dv = new DataView(memory.buffer);
  dv.setUint32(ptr, length, true);

  const arr = read(Uint8Array, memory, ptr + 4, length);
  for (let i = 0; i < length; i++) {
    arr[i] = str.charCodeAt(i);
  }
};

// Convert Porffor WASM values to JavaScript values
const porfToJSValue = ({ memory }, value, type) => {
  switch (type) {
    case TYPES.undefined:
      return undefined;

    case TYPES.number: 
      return value;
    case TYPES.numberobject: 
      return new Number(value);

    case TYPES.boolean: 
      return Boolean(value);
    case TYPES.booleanobject: 
      return new Boolean(value);

    case TYPES.object: {
      if (value === 0) return null;
      // For simplicity, return a basic object representation
      return `[Object at ${value}]`;
    }

    case TYPES.string: {
      if (value === 0) return '';
      return readByteStr(memory, value);
    }

    case TYPES.bytestring: {
      if (value === 0) return '';
      return readByteStr(memory, value);
    }

    default:
      return value;
  }
};

/**
 * Run a pre-compiled WASM file generated by Porffor
 * @param {string} wasmPath - Path to the WASM file
 * @returns {Promise<any>} - Result of executing the main function
 */
export default async function runWasmFile(wasmPath) {
  if (!fs.existsSync(wasmPath)) {
    throw new Error(`WASM file not found: ${wasmPath}`);
  }

  const wasmBuffer = fs.readFileSync(wasmPath);
  
  if (!wasmBuffer || wasmBuffer.length === 0) {
    throw new Error(`WASM file is empty: ${wasmPath}`);
  }

  // Initialize builtins to populate importedFuncs
  // Set up valtype globals like the main compiler does
  globalThis.valtype = Prefs.valtype ?? 'f64';
  globalThis.valtypeBinary = Valtype[valtype];
  
  // Create the standard runtime imports (similar to wrap.js)
  const print = str => process.stdout.write(str);
  createImport('print', 1, 0, i => print(i.toString()));
  createImport('printChar', 1, 0, i => print(String.fromCharCode(i)));
  createImport('time', 0, 1, () => performance.now());
  createImport('timeOrigin', 0, 1, () => performance.timeOrigin);

  // These will be updated later with the actual memory instance
  let memory;
  createImport('__Porffor_readArgv', 2, 1, (ind, outPtr) => {
    let args = process.argv.slice(2);
    args = args.slice(args.findIndex(x => !x.startsWith('-')) + 1);

    const str = args[ind - 1];
    if (!str) return -1;

    writeByteStr(memory, outPtr, str);
    return str.length;
  });
  
  createImport('__Porffor_readFile', 2, 1, (pathPtr, outPtr) => {
    try {
      const path = pathPtr === 0 ? 0 : readByteStr(memory, pathPtr);
      const contents = fs.readFileSync(path, 'utf8');
      writeByteStr(memory, outPtr, contents);
      return contents.length;
    } catch {
      return -1;
    }
  });
  
  BuiltinFuncs();

  try {
    const module = new WebAssembly.Module(wasmBuffer);
    const instance = new WebAssembly.Instance(module, {
      '': Object.keys(importedFuncs).reduce((acc, y) => {
        const x = importedFuncs[y];
        if (!x.import) return acc;

        acc[x.import] = x.js ?? (() => {});
        return acc;
      }, {})
    });

    // Now that we have the instance, set up the memory for imports that need it
    memory = instance.exports['$'];

    const exports = {};
    
    // Create wrapper functions for all exports
    for (const x in instance.exports) {
      if (x === '0' || x === '$') continue; // Skip exception tag and memory
      
      const wasm = instance.exports[x];
      exports[x === 'm' ? 'main' : x] = function(...args) {
        try {
          const result = wasm(...args);
          
          // For main function, try to convert result to JS value
          if (x === 'm' && result !== undefined) {
            // Assume f64 number type for simplicity - could be enhanced
            // to detect actual return type from WASM metadata
            return porfToJSValue({ memory }, result, TYPES.number);
          }
          
          return result;
        } catch (e) {
          // Re-throw with additional context
          const error = new Error(`Error executing WASM function '${x}': ${e.message}`);
          error.cause = e;
          throw error;
        }
      };
    }

    return { exports, wasm: wasmBuffer, memory };
  } catch (e) {
    if (e instanceof WebAssembly.CompileError) {
      throw new Error(`Failed to compile WASM file '${wasmPath}': ${e.message}`);
    } else if (e instanceof WebAssembly.LinkError) {
      throw new Error(`Failed to link WASM file '${wasmPath}': ${e.message}`);
    } else {
      throw new Error(`Failed to instantiate WASM file '${wasmPath}': ${e.message}`);
    }
  }
}